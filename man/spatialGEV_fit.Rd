% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spatialGEV_fit.R
\name{spatialGEV_fit}
\alias{spatialGEV_fit}
\title{Fit a GEV-GP model.}
\usage{
spatialGEV_fit(
  y,
  locs,
  random,
  init_param,
  reparam_s,
  kernel = "exp",
  X_a = NULL,
  X_b = NULL,
  X_s = NULL,
  nu = 1,
  s_prior = NULL,
  sp_thres = -1,
  adfun_only = FALSE,
  ignore_random = FALSE,
  silent = FALSE,
  ...
)
}
\arguments{
\item{y}{List of \code{n} locations each with \code{n_obs[i]} independent GEV realizations.}

\item{locs}{\verb{n x 2} matrix of longitude and latitude of the corresponding response values.}

\item{random}{Either "a", "ab", or "abs", where \code{a} indicates the location parameter,
\code{b} indicates the scale parameter, \code{s} indicates the shape parameter.  This tells the model
which GEV parameters are considered as random effects.}

\item{init_param}{A list of initial parameters. See details.}

\item{reparam_s}{A flag indicating whether the shape parameter is "zero", "unconstrained",
constrained to be "negative", or constrained to be "positive". If model "abs" is used,
\code{reparam_s} cannot be zero. See details.}

\item{kernel}{Kernel function for spatial random effects covariance matrix. Can be "exp"
(exponential kernel), "matern" (Matern kernel), or "spde" (Matern kernel with SPDE
approximation described in Lindgren el al. 2011).}

\item{X_a}{\verb{n x r} design matrix for a, where \code{r-1} is the number of covariates. If not
provided, a \verb{n x 1} column matrix of 1s is used.}

\item{X_b}{\verb{n x r} design matrix for log(b). Does not need to be provided if b is fixed.}

\item{X_s}{\verb{n x r} design matrix for g(s), where g() is a transformation function of \code{s}.
Does not need to be provided if s is fixed.}

\item{nu}{Hyperparameter of the Matern kernel. Default is 1.}

\item{s_prior}{Optional. A length 2 vector where the first element is the mean of the normal
prior on s or log(s) and the second is the standard deviation. Default is NULL, meaning a
uniform prior is put on s if s is fixed, or a GP prior is applied if s is a random effect.}

\item{sp_thres}{Optional. Thresholding value to create sparse covariance matrix. Any distance
value greater than or equal to \code{sp_thres} will be set to 0. Default is -1, which means not
using sparse matrix. Caution: hard thresholding the covariance matrix often results in bad
convergence.}

\item{adfun_only}{Only output the ADfun constructed using TMB? If TRUE, model fitting is not
performed and only a TMB tamplate \code{adfun} is returned (along with the created mesh if kernel is
"spde").
This can be used when the user would like to use a different optimizer other than the default
\code{nlminb}. E.g., call \code{optim(adfun$par, adfun$fn, adfun$gr)} for optimization.}

\item{ignore_random}{Ignore random effect? If TRUE, spatial random effects are not integrated
out in the model. This can be helpful for checking the marginal likelihood.}

\item{silent}{Do not show tracing information?}

\item{...}{Arguments to pass to \code{INLA::inla.mesh.2d()}. See details \code{?inla.mesh.2d()} and
Section 2.1 of Lindgren & Rue (2015) JSS paper.
This is used specifically for when \code{kernel="spde"}, in which case a mesh needs to be
constructed on the spatial domain. When no arguments are passed to \code{inla.mesh.2d()}, a
default argument is \code{max.edge=c(1,2)}, which simply specifies the largest allowed triangle edge
length. It is strongly suggested that the user should specify these arguments if they would
like to use the SPDE kernel.}
}
\value{
If \code{adfun_only=TRUE}, this function outputs a list returned by \code{TMB::MakeADFun()}.
This list contains components \verb{par, fn, gr} and can be passed to an R optimizer.
If \code{adfun_only=FALSE}, this function outputs an object of class \code{spatialGEVfit}, a list
\itemize{
\item An adfun object
\item A fit object given by calling \code{nlminb()} on the adfun
\item An object of class \code{sdreport} from TMB which contains the point estimates, standard error,
and precision matrix for the fixed and random effects
\item Other helpful information about the model: kernel, data coordinates matrix, and optionally
the created mesh if `kernel="spde" (See details).
}
}
\description{
Fit a GEV-GP model.
}
\details{
This function adopts Laplace approximation using TMB model to integrate out the random effects.

The random effects are assumed to follow Gaussian processes with mean 0 and covariance matrix
defined by the chosen kernel function. E.g., using the exponential kernel function:\preformatted{cov(i,j) = sigma*exp(-|x_i - x_j|/ell)
}

When specifying the initial parameters to be passed to \code{init_param}, care must be taken to
count the number of parameters. Described below is how to specify \code{init_param} under different
settings of \code{random} and \code{kernel}. Note that the order of the parameters must match the
descriptions below (initial values specified below such as 0 and 1 are only examples).
\itemize{
\item random = "a", kernel = "exp":
\code{a} should be a vector and the rest are scalars. \code{log_sigma_a} and \code{log_ell_a} are
hyperparameters in the exponential kernel for the Gaussian process describing the spatial
variation of \code{a}.
}\preformatted{init_param = list(beta_a = rep(0, n_covariates), 
                  a = rep(1,n_locations), log_b = 0, s = 1,
                  log_sigma_a = 0, log_ell_a = 0)
}

Note that even if \code{reparam_s=="zero"}, an initial value for \code{s} still must be provided, even
though in this case the value does not matter anymore.
\itemize{
\item random = "ab", kernel = "exp":
When \code{b} is considered a random effect, its corresponding GP hyperparameters \code{log_sigma_b}
and \code{log_ell_b} need to be specified.
}\preformatted{init_param = list(beta_a = rep(0, n_covariates), beta_b = rep(0, n_covariates),
                  a = rep(1,n_locations),
                  log_b = rep(0,n_locations), s=1,
                  log_sigma_a = 0,log_ell_a = 0, 
                  log_sigma_b = 0,log_ell_b = 0).
}
\itemize{
\item random = "abs", kernel = "exp":
}\preformatted{init_param = list(beta_a = rep(0, n_covariates), 
                  beta_b = rep(0, n_covariates),
                  beta_s = rep(0, n_covariates),
                  a = rep(1,n_locations),
                  log_b = rep(0,n_locations), 
                  s = rep(0,n_locations),
                  log_sigma_a = 0,log_ell_a = 0, 
                  log_sigma_b = 0,log_ell_b = 0).
                  log_sigma_s = 0,log_ell_s = 0).
}
\itemize{
\item random = "abs", kernel = "matern" or "spde":
When the Matern or SPDE kernel is used, hyperparameters for the GP kernel are \code{log_sigma_a/b/s}
and \code{log_kappa_a/b/s} for each spatial random effect.
}\preformatted{init_param = list(beta_a = rep(0, n_covariates), 
                  beta_b = rep(0, n_covariates),
                  beta_s = rep(0, n_covariates),
                  a = rep(1,n_locations),
                  log_b = rep(0,n_locations), 
                  s = rep(0,n_locations), 
                  log_sigma_a = 0,log_kappa_a = 0, 
                  log_sigma_b = 0,log_kappa_b = 0).
                  log_sigma_s = 0,log_kappa_s = 0).
}

\code{raparam_s} allows the user to reparametrize the GEV shape parameter \code{s}. For example,
\itemize{
\item if the data is believed to be right-skewed and lower bounded, this means \code{s>0} and one should
use \code{reparam_s = "positive"};
\item if the data is believed to be left-skewed and upper bounded, this means \code{s<0} and one should
use \code{reparam_s="negative"}.
\item When \code{reparam_s = "zero"}, the data likelihood is a Gumbel distribution. In this case the data
has no upper nor lower bound. Finally, specify \code{reparam_s = "unconstrained"} if no sign
constraint should be imposed on \code{s}.
}

Note that when reparam_s = "negative" or "postive", the initial value of \code{s} in \code{init_param}
should be that of log(|s|).

When the SPDE kernel is used, a mesh on the spatial domain is created using
\verb{INLA::inla.mesh.2d()', which extends the spatial domain by adding additional triangles in the mesh to avoid boundary effects in estimation. As a result, the number of }a\code{and}b\verb{ will be greater than the number of locations due to these additional triangles: each of them also has their own}a\code{and}b\verb{values. Therefore, the fit function will return a vector}meshidxloc` to
indicate the positions of the observed coordinates in the random effects vector.
}
\examples{
\dontrun{
library(SpatialGEV)
a <- simulatedData$a
logb <- simulatedData$logb
logs <- simulatedData$logs
y <- simulatedData$y
locs <- simulatedData$locs
n_loc = nrow(locs)
# No covariates are included, only intercept is inlcuded.
fit <- spatialGEV_fit(y = y, locs = locs, random = "ab",
                      init_param = list(beta_a = 0,
                                        beta_b = 0,
                                        a = rep(0, n_loc), 
                                        log_b = rep(0, n_loc), 
                                        s = 0,
                                        log_sigma_a = 0, 
                                        log_kappa_a = 0,
                                        log_sigma_b = 0, 
                                        log_kappa_b = 0),
                      reparam_s = "positive",
                      kernel = "matern",
                      X_a = matrix(1, nrow=n_loc, ncol=1),
                      X_b = matrix(1, nrow=n_loc, ncol=1),
                      silent = TRUE) 
print(fit)

# Using the SPDE kernel (SPDE approximation to the Matern kernel)
fit_spde <- spatialGEV_fit(y = y, locs = locs, random = "ab",
                           init_param = list(beta_a = 0,
                                             beta_b = 0,
                                             log_b = rep(0, n_loc), 
                                             s = 0,
                                             log_sigma_a = 0, 
                                             log_kappa_a = 0,
                                             log_sigma_b = 0, 
                                             log_kappa_b = 0),
                           reparam_s = "positive",
                           kernel = "spde",
                           X_a = matrix(1, nrow=n_loc, ncol=1),
                           X_b = matrix(1, nrow=n_loc, ncol=1),
                           adfun_only = TRUE) 
library(INLA)
plot(fit_spde$mesh) # Plot the mesh
points(locs[,1], locs[,2], col="red", pch=16) # Plot the locations
}
}
